#include <iostream>
#include <sstream>
#include <bitset>
#include <conio.h>
#include <fstream>
#include <math.h>
using namespace std;


class DES
{
public:  

    DES() {
        file.open("log.md");
        file << "# Log\r\rThis is the log generated by DES Algorithm\r\r";
    }

    //encryption algorithm
    string encrypt(string plainText,string key1,int mode = 0)
    {
        bitset<64> block = mode ?stringHexToHex(plainText) : stringToHex(plainText);
        bitset<64> key = mode ?stringHexToHex(key1) : stringToHex(key1);
        
        
        file << "## **Encryption :**\r\r";
        file << "**Plain Text :`"  << hex << block.to_ullong() << "`**\r\r**Key: `" << key.to_ullong() << "`**\r\r" << dec;
        bitset<64> cipherText = this->algo(block,key);        

        file << "**Cipher Text :`" << hex << cipherText.to_ullong() << dec <<  "`**\r\r";
        return  hexToStringHex( cipherText.to_ullong() );

    }
    //decryptions algorithm
    string decrypt(string cipherText,string key1 , int mode = 0)
    {

        bitset<64> block = stringHexToHex(cipherText);
        bitset<64> key = mode ?stringHexToHex(key1) : stringToHex(key1);
        file << "## **Decryption :**\r\r";
        file << "**Cipher Text: `"  << hex << block.to_ullong() << "`**\r\r**Key: `" << key.to_ullong() << "`**\r\r" << dec;
        bitset<64> decodedText = this->algo(block,key,1);        

        file << "**Plain Text: `" << hex << decodedText.to_ullong() << dec <<  "`**\r\r";
        return  mode? hexToStringHex( decodedText.to_ullong() ) : hexToString( decodedText.to_ullong() );
    }

    //DES algo
    bitset<64> algo(bitset<64> block, bitset<64> key, int mode = 0) {
        // bitset<64> block = 0x0123456789ABCDEF;
        int keyStart = 0;
        if(mode)
            keyStart = 17;


        file << "## STEP 1\r\rCreate 16 subkeys, each of which is 48-bits long.\r\r";
        // bitset<64> key =   0x133457799BBCDFF1;

        file << "64 bit key:\r\r";
        print<64>(key,8);
        
        //Covert to 56 bit key
        bitset<56> k_56 =  pc1(key);
        file << "56 bit key:\r" << endl;
        print<56>(k_56,7);
        file << "\r";

        //Shifting the keys
        bitset<28>c[17],d[17];

        c[0] = firstHalf<56>(k_56);
        d[0] = secondHalf<56>(k_56);
        c[1] = circularShift<28>(c[0],1);
        d[1] = circularShift<28>(d[0],1);
        int j = 0;
        for(int i = 2; i <= 16; i++)
        {
            int num = 2;
            if(j % 7 == 0)
                num = 1;
            c[i] = circularShift<28>(c[i-1],num);
            d[i] = circularShift<28>(d[i-1],num);
            j++;

        }

        file << "Shifting 56 bit key for 16 rounds\r\r";
         for(int i = 0; i <= 16; i++) {
             file << "c" << i << " & d" <<i << " :\r\r";
             print<28>(c[i],7);
             print<28>(d[i],7);
         }


      
        file << "Generating 16 subkeys of size 48\r\r";
        bitset<48> k_48[17];
        for(int i = 1; i <=16; i++) {
            k_48[i] = pc2( mergeTwo<28>(c[i], d[i]) );
        }


        for(int i = 1; i <=16; i++) {
             file << "K" << i << " :\r\r";
            print<48>(k_48[i],6);
        }


        file << "\r## STEP 2\r\rEncoding 64 bit plain Text.\r\r";
        file << "Plain Text:\r\r";
        print<64>(block,8);

        file << "Initial Permuted Text :\r\r";

        bitset<64> ipText = ipTable(block);
        print<64>(ipText,8);

        bitset<32> l[17],r[17];
        l[0] = firstHalf<64>(ipText);
        r[0] = secondHalf<64>(ipText);

        

        for(int i = 1; i < 17; i++) {
            l[i] = r[i-1];
            int keyPos = keyStart - i;
            keyPos = keyPos > 0 ? keyPos: keyPos * -1;
            r[i] = l[i-1] ^ function(r[i-1] , k_48[ keyPos ]);
        }

        for(int i = 0; i < 17; i++) {
             file << "L" << i << " & R " << i << ":\r\r";
             print<32>(l[i],4);
             print<32>(r[i],4);
        }
        file << "\r\r R16L16:\r\r";
        bitset<64> cipherText = mergeTwo<32>(r[16],l[16]);
        print<64> (cipherText,8);
        file << "\r\r Final block(IP Inverse) :\r\r";
        cipherText = ipInverse(cipherText);
        print<64> (cipherText,8);
        return cipherText;
    }




   /********************************************
   *                  STEP 1                   *
   ********************************************/
    //PC-1 Table
    bitset<56> pc1(bitset<64> key)
    {
        const int pc1Arr[56] =
        {
            57, 49,  41, 33,  25,  17,  9,
            1, 58,  50, 42,  34,  26, 18,
            10,  2,  59, 51,  43,  35, 27,
            19, 11,   3, 60,  52,  44, 36,
            63, 55,  47, 39,  31,  23, 15,
            7, 62,  54, 46,  38,  30, 22,
            14,  6,  61, 53,  45,  37, 29,
            21, 13,   5, 28,  20,  12,  4
        };
        bitset<56> bit56key;
        int count1 = 0;
        for(int i = 55; i >= 0; i--)
        {

            bit56key[i] = key[64 - pc1Arr[count1++]];


        }
        return bit56key;
    }


    //PC-2 Table
    bitset<48> pc2(bitset<56> key)
    {
        const int pc2Arr[48] =
        {
            14, 17,  11, 24,  1, 5,
            3, 28,  15,  6, 21, 10,
            23, 19,  12,  4, 26, 8,
            16,  7,  27, 20, 13, 2,
            41, 52,  31, 37, 47, 55,
            30, 40,  51, 45, 33, 48,
            44, 49,  39, 56, 34, 53,
            46, 42,  50, 36, 29, 32
        };
        bitset<48> bit48key;
        int count1 = 0;
        for(int i = 47; i >= 0; i--)
        {

            bit48key[i] = key[56 - pc2Arr[count1++]];


        }
        return bit48key;
    }

    

    /********************************************
   *                  STEP 2                   *
   ********************************************/

    bitset<64> ipTable(bitset<64> text) {
        const int IP[64] = {
            58,   50,  42,   34,   26,  18,   10,   2,
            60,   52,  44,   36,   28,  20,   12,   4,
            62,   54,  46,   38,   30,  22,   14,   6,
            64,   56,  48,   40,   32,  24,   16,   8,
            57,   49,  41,   33,   25,  17,    9,   1,
            59,   51,  43,   35,   27,  19,   11,   3,
            61,   53,  45,   37,   29,  21,   13,   5,
            63,   55,  47,   39,   31,  23,   15,   7
        };
        bitset<64> ipText;
        int count = 0;
        for (int i = 63; i >= 0; i--) {
            ipText[i] = text[ 64 - IP[count++] ];
        }
        return ipText;

    }

    bitset<48> ebitTable(bitset<32> a) {
        const int ebit[48] = {
                32,   1,   2,    3,    4,   5,
                4,    5,   6,    7,    8,   9,
                8,    9,   10,   11,   12,  13,
                12,   13,  14,   15,   16,  17,
                16,   17,  18,   19,   20,  21,
                20,   21,  22,   23,   24,  25,
                24,   25,  26,   27,   28,  29,
                28,   29,  30,   31,   32,   1
        };
        bitset<48> eR;
        int count1 = 0;
        for(int i = 47; i >= 0; i--)
        {

            eR[i] = a[32 - ebit[count1++]];


        }
        return eR;
    }

    bitset<32> function(bitset<32> r, bitset<48> k) {
        //Ebit
        bitset<48> eR = ebitTable(r);
        //XOR
        bitset<48> k_er = k ^ eR;
        //Sbox
        bitset <32> stext =  sbox(k_er);
        //Pbox
        bitset<32> ptext = pbox(stext);
        
        return ptext;
    }

    bitset<32> sbox(bitset<48> k_er) {
        const int s[8][4][16] = {
            {
                {14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7},
                {0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},
                {4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0},
                {15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}
            },
            {
                {15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10},
                {3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5},
                {0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15},
                {13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9}
            },
            {
                {10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8},
                {13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1},
                {13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7},
                {1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12}
            },
            {
                {7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15},   
                {13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9},
                {10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4},
                {3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14}
            },
            {
               {2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9},
               {14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6},
               {4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14},
               {11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3}
            },
            {
                {12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11},
                {10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8},
                {9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6},
                {4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13}
            },
            {
                {4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1},
                {13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6},
                {1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2},
                {6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12}
            },
            {
                {13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7},
                {1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2},
                {7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8},
                {2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}
            }
        };

        /*for(int i = 0;  i < 8; i++) {
            file << "S" << i+1 << "\r\r";
            for (int j = 0; j < 4; j++) {
                file << "\t";
                for (int k = 0; k < 16; k++) {
                    file << s[i][j][k] << " " ;
                }
                file << "\r";
            }
            file << "\r\r";
        }*/

        bitset<6> ker_6[8];
        int row = 0,col = 5;
        for(int i = 47; i >=0; i--) {
            ker_6[row][col--] = k_er[i];
            if(i%6 == 0) {
                row++;
                col = 5;
            }
        }

        // // file << "k + er\r\r";
        // print<48> (k_er,6);
       
        bitset<4> ker_4[8];
        for(int i = 0; i < 8 ; i++) { 
            bitset<2> rowBit;
            rowBit[1] = ker_6[i][5];
            rowBit[0] = ker_6[i][0];
            ker_6[i][5] = 0;
            ker_6[i] >>= 1;
            int row = rowBit.to_ulong();
            int col = ker_6[i].to_ulong();
            ker_4[i] =s[i][row][col];
        }

        unsigned long num = 0;
        for(int i = 0; i < 8; i++) {
            num <<= 4;
            num = num | ker_4[i].to_ulong();
        }

        bitset<32> stext = num;
        return stext;





        
    }

    bitset<32> pbox(bitset<32> a) {
        const int pb[32] = {
            16,7,20,21,
            29,12,28,17,
            1,15,23,26,
            5,18,31,10,
            2,8,24,14,
            32,27,3,9,
            19,13,30,6,
            22,11,4,25
        };

        bitset<32> ptext;
        int count1 = 0;
        for(int i = 31; i >= 0; i--)
        {

            ptext[i] = a[32 - pb[count1++]];


        }
        return ptext;
    }

     bitset<64> ipInverse(bitset<64> text) {
        const int IP[64] = {
            40,8,48,16,56,24,64,32,
            39,7,47,15,55,23,63,31,
            38,6,46,14,54,22,62,30,
            37,5,45,13,53,21,61,29,
            36,4,44,12,52,20,60,28,
            35,3,43,11,51,19,59,27,
            34,2,42,10,50,18,58,26,
            33,1,41,9,49,17,57,25
        };
        bitset<64> ipText;
        int count = 0;
        for (int i = 63; i >= 0; i--) {
            ipText[i] = text[ 64 - IP[count++] ];
        }
        return ipText;

    }

   /********************************************
   *                  UTILS                    *
   ********************************************/

    //Merge key parts
    template <int T>
    bitset<2*T> mergeTwo(bitset<T> a,bitset<T> b) {
        bitset<2*T> key;

        for(int i = 0; i < 2*T; i++) {
            if(i < T) {
                key[i] = b[i];
            } else
                key[i] = a[i-T];
        }

        return key;

    }




    //Print in format
    template <int T>
    void print(bitset<T> a,int blockSize) {
        file << "    ";
        for(int i = T - 1; i >= 0; i--)
        {
             file << a[i] ;
            if(i % (blockSize) == 0 && i!=0)
                file << " ";
           
        }
        file << "\r";

    }


    //Circular Shift
    template <int T>
    bitset<T> circularShift(bitset<T> a,int num)
    {

        int overflow[num];
        for(int i = 0; i < num; i++)
        {
            overflow[i] = a[T-1-i];
        }

        a = a << num;
        int count1 = 0;
        for(int i = num-1; i >= 0; i--)
        {
            a[i] = overflow[count1++];
        }
        return a;
    }

    template <int T>
    bitset<T/2> firstHalf(bitset<T> a) {
        bitset<T/2> first;
        int count = 0;
        for (int i = T/2; i < T; i++) {
            first[count++] = a[i];
        }
        return first;
    }
    template <int T>
    bitset<T/2> secondHalf(bitset<T> a) {
        bitset<T/2> second;
        int count = 0;
        for (int i = 0; i < T/2; i++) {
            second[count++] = a[i];
        }
        return second;
    }

    unsigned long long stringToHex(string name) {
        unsigned long long hexa = 0;
        if(name.length() >= 8)
        name = name.substr(0,8);
        else
        name = name.append(8-name.length(),' ');
        for(int i = 0; i < name.length(); i++) {
            hexa <<= 8;
            hexa |= name[i];
        }
        return hexa;
    }

    string hexToString(unsigned long long num) {
        string text = "";
        int count = 0;
        while(count < 8) {
            unsigned int div = 0b11111111;
            div = num & div;
            num >>= 8;
            text = (char) div + text;
            count ++;
        }

        return text;
        
    }

    unsigned long long stringHexToHex(string Hex) {
        stringstream ss;
        unsigned long long num;
        ss << Hex;
        ss >> hex >>num;
        return num;
    }

    string hexToStringHex(unsigned long long num) {
        stringstream ss;
        string s;
        ss << hex << num;
        ss >>  s;
        return s;
    }




private:
    ofstream file;

};

unsigned long long stringToHex(string name) {
    unsigned long long hexa = 0;
    if(name.length() >= 8)
    name = name.substr(0,8);
    else
    name = name.append(8-name.length(),' ');
    
    for(int i = 0; i < name.length(); i++) {
        hexa <<= 8;
        hexa |= name[i];
    }
    return hexa;
}

string hexToString(unsigned long long num) {
     string text = "";
     int count = 0;
     while(count < 8) {
         unsigned int div = 0b11111111;
         div = num & div;
         num >>= 8;
         text = (char) div + text;
         count ++;
     }

     return text;   
}

    unsigned long long stringHexToHex(string Hex) {
        stringstream ss;
        unsigned long long num;
        ss << Hex;
        ss >> hex >>num;
        return num;
    }

    string hexToStringHex(unsigned long long num) {
        stringstream ss;
        string s;
        ss << hex << num;
        ss >>  s;
        return s;
    }

int main()
{

    DES a;
    string message= "123456789abcdef";
    string key = "133457799BBcDFF1";
    string cipherText;
    string decodedText;
    cipherText =  a.encrypt(message,key,1);
    decodedText = a.decrypt(cipherText,key,1);


    cout << "Message: " << message << endl << "Key: " << key <<  endl << endl << "Encrypt: " << cipherText << endl
    << "Decrypt: " << decodedText << endl <<  endl;

    
    
    return 0;
}
